#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# decide path to cd intelligently


import os
import argparse
import glob

from common import rpcl_safe, RpclIoManager, color_info, color_err


ORDERED_ENVVAR_DIRS_TO_CHECK = [
    'WORKSPACE',
    'DESKTOP'
]
MAX_PATHS_TO_CHECK = 10000


def check_parent_for_matches(dparent, dname):
    """Checks a given directory to see if it contains the given prefix; if so,
    asks the user for input as to which is intended.

    Args:
        dparent (str): The path of the parent directory.
        dname (str): The prefix of the internal directory.
    Returns:
        (str): The path found, or None if none exist.
    """
    paths = []
    for recursive in [False, True]:
        for i, e in enumerate(glob.iglob(dparent + '/**/', recursive=recursive)):
            if i >= MAX_PATHS_TO_CHECK:
                break
            if dname.lower() in e.lower() and (len(paths) == 0 or not e.startswith(paths[-1])):
                paths.append(e)
        if len(paths) != 0:
            break
    paths = sorted(paths)

    if len(paths) == 0:
        return None
    if len(paths) == 1:
        return os.path.join(dparent, paths[0])

    for i, suffix in enumerate(paths):
        print(f'[{i + 1}]: {color_info(suffix)}')
    print(f'[{len(paths) + 1}]: {color_err(None)}')

    while True:
        try:
            choice = int(input()) - 1
            if not 0 <= choice <= len(paths):
                continue
            break
        except ValueError:
            continue

    if choice == len(paths):
        return None
    return os.path.join(dparent, paths[choice])


@rpcl_safe
def main():
    """The main function."""
    parser = argparse.ArgumentParser(description='A CLI to change directories intelligently, then list the contents.')
    parser.add_argument('dir', nargs='+', help='the name or substring of the directory')
    RpclIoManager(parser)
    args = parser.parse_args()

    dname = os.path.expanduser(' '.join(args.dir))
    if dname == '':
        exit(os.path.expanduser('~'))
    if dname.startswith('/') or dname.startswith('.'):
        exit(dname)

    dparents = [os.getcwd()] + [os.environ[e] for e in ORDERED_ENVVAR_DIRS_TO_CHECK]

    for i, dparent in enumerate(dparents):
        if i != 0:
            print(f'Checking in {color_info(dparent)}')

        dpath = check_parent_for_matches(dparent, dname)
        if dpath is not None:
            exit(dpath)

    print(color_err(f'Could not find \'{dname}\'.'))
    exit()


if __name__ == '__main__':
    main()
