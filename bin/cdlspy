#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# decide path to cd intelligently


import os
import argparse
import re
from os import path

from common import color_info, color_err
from rpcl import rpcl_safe, RpclManager


ORDERED_ENVVAR_DIRS_TO_CHECK = [
    'WORKSPACE',
    'DESKTOP',
    'MISC'
]
MAX_DEPTH = 5


@rpcl_safe
def main():
    """The main function."""
    parser = argparse.ArgumentParser(description='A CLI to change directories intelligently, then list the contents.')
    parser.add_argument('dir', nargs='*', help='the name or substring of the directory')
    RpclManager(parser)
    args = parser.parse_args()

    args_search = ' '.join(args.dir)
    if args_search == '':
        args_search = '~'
    search = path.expanduser(args_search).lower()

    match = re.match(r'\.+', search)
    if match is not None:
        n_dots = match.end()
        rel = './' + '../' * (n_dots - 1)
        if n_dots == len(search):
            exit(path.abspath(rel))
        search = rel + search[n_dots:]

    if len(search) != 1 and search.endswith('/'):
        search = search[:-1]

    q = [os.getcwd()] + [path.expanduser(os.environ[e]) for e in ORDERED_ENVVAR_DIRS_TO_CHECK]
    if search.startswith('/') or search.startswith('.'):
        full = path.abspath(search)
        if path.isdir(full):
            # can case incorrectly if the case is wrong in the search
            exit(full)
        parent_full = path.dirname(full)
        if not path.isdir(parent_full):
            print(color_err(f'Could not find \'{full}\'.'))
            exit()
        q = [parent_full]
        search = os.path.basename(full)

    q = [(e, '', -1) for e in q]
    while True:
        root, curr, depth = q.pop(0)
        if depth > MAX_DEPTH:
            break
        parent = path.join(root, curr)
        try:
            children = sorted((e.name for e in os.scandir(parent) if e.is_dir()), key=str.lower)
        except PermissionError:
            continue
        for child in children:
            n_path = path.join(curr, child)
            if search in n_path.lower():
                exit(path.join(root, n_path))
            q.append((root, n_path, depth + 1))

    print(color_err(f'Could not find \'{search}\'.'))
    exit()


if __name__ == '__main__':
    main()
