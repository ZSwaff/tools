#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# decide path to cd intelligently


import os
import argparse
import glob

from termcolor import colored

from common import RpclIOManager


ORDERED_ENVVAR_DIRS_TO_CHECK = [
    'WORKSPACE',
    'DESKTOP'
]
MAX_PATHS_TO_CHECK = 10000


def check_parent_for_matches(dparent, dname):
    """Checks a given directory to see if it contains the given prefix; if so,
    asks the user for input as to which is intended.

    Args:
        dparent (str): The path of the parent directory.
        dname (str): The prefix of the internal directory.
    Returns:
        (str): The path found, or None if none exist.
    """
    paths = []
    for recursive in [False, True]:
        for i, e in enumerate(glob.iglob(dparent + '/**/', recursive=recursive)):
            if i >= MAX_PATHS_TO_CHECK:
                break
            if dname.lower() in e.lower() and (len(paths) == 0 or not e.startswith(paths[-1])):
                paths.append(e)
        if len(paths) != 0:
            break
    paths = sorted(paths)

    if len(paths) == 0:
        return None
    if len(paths) == 1:
        return os.path.join(dparent, paths[0])

    for i, suffix in enumerate(paths):
        print('[{}]: {}'.format(i + 1, colored(suffix, 'blue')))
    print('[{}]: {}'.format(len(paths) + 1, colored('None', 'red')))

    while True:
        try:
            choice = int(input()) - 1
            if not 0 <= choice <= len(paths):
                continue
            break
        except ValueError:
            continue

    if choice == len(paths):
        return None
    return os.path.join(dparent, paths[choice])


def main():
    """The main function."""
    parser = argparse.ArgumentParser(description='A CLI to change directories intelligently, then list the contents.')
    parser.add_argument('dir', nargs='*', help='the name or prefix of the directory')
    RpclIOManager(parser)
    args = parser.parse_args()

    dname = os.path.expanduser(' '.join(args.dir))
    if dname == '':
        exit(os.path.expanduser('~'))
    if dname.startswith('/') or dname.startswith('.'):
        exit(dname)

    dparents = [os.getcwd()] + [os.environ[e] for e in ORDERED_ENVVAR_DIRS_TO_CHECK]

    for i, dparent in enumerate(dparents):
        if i != 0:
            print('Checking in {}'.format(colored(dparent, 'blue')))

        dpath = check_parent_for_matches(dparent, dname)
        if dpath is not None:
            exit(dpath)

    print(colored('Could not find {}.', 'red').format(colored(dname, 'blue')))
    exit('.')


if __name__ == '__main__':
    try:
        main()
    except Exception as ex:
        print(repr(ex))
        exit('.')
